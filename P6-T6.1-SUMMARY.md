# P6-T6.1 구독 DB 스키마 설계 및 마이그레이션 - 작업 완료 요약

## 작업 개요

**Phase**: 6 (구독 및 결제)
**태스크**: P6-T6.1
**상태**: ✅ 완료
**작성일**: 2024-01-28

구독 및 결제 기능을 지원하는 PostgreSQL 데이터베이스 스키마를 설계하고 마이그레이션 파일을 작성했습니다.

---

## 산출물 (5개)

### 1. 마이그레이션 스크립트
```
📄 supabase/migrations/018_create_subscription_tables.sql (340줄)
```

**포함 내용**:
- 3개 테이블 (subscriptions, payment_history, plan_limits)
- 7개 인덱스 (성능 최적화)
- 1개 트리거 (updated_at 자동 업데이트)
- 7개 RLS 정책 (보안)
- 7개 PL/pgSQL 함수 (비즈니스 로직)

### 2. TypeScript 타입 정의
```
📄 src/types/subscription.ts (7,294 bytes)
```

**포함 내용**:
- 5개 Union 타입 (SubscriptionPlan, SubscriptionStatus, PaymentStatus, PaymentMethod, PaymentProvider)
- 7개 인터페이스 (Subscription, PaymentHistory, PlanLimits, 등)
- 4개 UI용 인터페이스 (SubscriptionInfo, PricingCard, 등)
- 2개 상수 (PLAN_LIMITS_DEFAULTS, PRICING_CARDS)

### 3. 마이그레이션 요약 문서
```
📄 supabase/migrations/018_MIGRATION_SUMMARY.md
```

**포함 내용**:
- 각 테이블 상세 설명
- 각 함수 사용 방법
- 데이터 흐름 (2가지 플로우)
- 마이그레이션 검증 체크리스트

### 4. 완료 보고서
```
📄 P6-T6.1-COMPLETION-REPORT.md
```

**포함 내용**:
- 작업 요약
- 완료 항목 체크리스트
- 스키마 설계 상세 (정규화, 설계 의사결정)
- 데이터 흐름 (다이어그램 포함)
- 마이그레이션 적용 방법 (3가지)
- 검증 방법 (5가지 SQL)
- TypeScript 사용 예시
- 문제 해결

### 5. 검증 및 설치 가이드
```
📄 P6-T6.1-VERIFICATION.md
```

**포함 내용**:
- 파일 검증 결과 (✅ PASS)
- 설치 방법 (3가지)
- 검증 체크리스트 (5개 항목)
- 함수 테스트 예시
- 주의사항
- 문제 해결

---

## 생성된 데이터베이스 구조

### 테이블 (3개)

#### 1. subscriptions
사용자의 구독 정보 관리
```sql
- id: UUID (PK)
- user_id: UUID (FK → auth.users, UNIQUE)
- plan: TEXT ('free', 'pro', 'business')
- status: TEXT ('active', 'canceled', 'past_due', 'trialing')
- current_period_start, current_period_end: TIMESTAMPTZ
- cancel_at_period_end: BOOLEAN
- payment_provider: TEXT ('toss')
- payment_customer_id: TEXT (Toss 고객 ID)
- payment_subscription_id: TEXT (Toss 구독 ID)
- created_at, updated_at: TIMESTAMPTZ
```

**인덱스 (2개)**:
- idx_subscriptions_user_id
- idx_subscriptions_payment_customer_id

#### 2. payment_history
결제 거래 기록
```sql
- id: UUID (PK)
- subscription_id: UUID (FK → subscriptions)
- user_id: UUID (FK → auth.users)
- amount: INTEGER (원)
- currency: TEXT ('KRW')
- status: TEXT ('pending', 'succeeded', 'failed', 'refunded')
- payment_method: TEXT ('card', 'bank_transfer')
- payment_key: TEXT (Toss 결제 키)
- order_id: TEXT (주문번호, UNIQUE)
- receipt_url: TEXT
- paid_at: TIMESTAMPTZ
- created_at: TIMESTAMPTZ
```

**인덱스 (5개)**:
- idx_payment_history_user_id
- idx_payment_history_subscription_id
- idx_payment_history_order_id
- idx_payment_history_status
- idx_payment_history_created_at

#### 3. plan_limits
구독 플랜별 기능 제한 (정적 데이터)
```sql
- plan: TEXT (PK: 'free', 'pro', 'business')
- max_guidebooks: INTEGER (-1: 무제한)
- max_ai_generations_per_month: INTEGER (-1: 무제한)
- watermark_removed: BOOLEAN
- custom_domain: BOOLEAN
- priority_support: BOOLEAN
- price_yearly: INTEGER (원, 연간 가격)
- created_at: TIMESTAMPTZ
```

**초기 데이터**:
```
free:     1 가이드북, 3 AI/월, 무료
pro:      5 가이드북, 30 AI/월, 워터마크 제거, 49,000원
business: 무제한, 우선 지원, 커스텀 도메인, 99,000원
```

---

## RLS 정책 (7개)

| 테이블 | 정책명 | 액션 | 규칙 |
|-------|--------|------|------|
| subscriptions | subscriptions_select_own | SELECT | user_id = auth.uid() |
| subscriptions | subscriptions_insert_own | INSERT | user_id = auth.uid() |
| subscriptions | subscriptions_update_own | UPDATE | user_id = auth.uid() |
| subscriptions | subscriptions_delete_own | DELETE | user_id = auth.uid() |
| payment_history | payment_history_select_own | SELECT | user_id = auth.uid() |
| payment_history | payment_history_insert_own | INSERT | user_id = auth.uid() |
| plan_limits | plan_limits_select_public | SELECT | true (공개) |

---

## Helper 함수 (7개)

### 조회 함수

#### 1. get_user_plan(user_id) → TEXT
사용자의 현재 플랜 조회
```sql
SELECT get_user_plan('user-id'::uuid);
-- 반환: 'free', 'pro', 'business' (기본값: 'free')
```

#### 2. get_plan_limits(plan) → plan_limits
특정 플랜의 제한 사항 조회
```sql
SELECT * FROM get_plan_limits('pro');
-- 반환: max_guidebooks=5, max_ai_generations_per_month=30, ...
```

#### 3. get_user_plan_limits(user_id) → plan_limits
사용자 플랜의 제한 사항 조회
```sql
SELECT * FROM get_user_plan_limits('user-id'::uuid);
```

#### 4. is_subscription_active(user_id) → BOOLEAN
사용자의 활성 구독 여부 확인
```sql
SELECT is_subscription_active('user-id'::uuid);
-- 반환: true/false
```

### 결제 처리 함수 (Service Role 필요)

#### 5. create_payment_record(...) → (id, created_at)
Toss 결제 후 결제 기록 생성
```sql
SELECT * FROM create_payment_record(
    'sub-id'::uuid,      -- subscription_id
    'user-id'::uuid,     -- user_id
    49000,               -- amount
    'card',              -- payment_method
    'toss-key-123',      -- payment_key
    'order-123'          -- order_id
);
```

#### 6. update_payment_status(payment_id, status, receipt_url) → BOOLEAN
결제 상태 업데이트 (pending → succeeded/failed)
```sql
SELECT update_payment_status(
    'payment-id'::uuid,
    'succeeded',
    'https://receipt.toss.im/...'
);
```

#### 7. update_subscription_from_payment(...) → (id, user_id, plan, status)
결제 완료 후 구독 정보 업데이트
```sql
SELECT * FROM update_subscription_from_payment(
    'user-id'::uuid,        -- user_id
    'pro',                  -- plan
    'toss',                 -- payment_provider
    'cust-123',             -- payment_customer_id
    'sub-123',              -- payment_subscription_id
    NOW(),                  -- current_period_start
    NOW() + INTERVAL '1 year'  -- current_period_end
);
```

---

## TypeScript 타입 상세

### 기본 타입
```typescript
type SubscriptionPlan = 'free' | 'pro' | 'business';
type SubscriptionStatus = 'active' | 'canceled' | 'past_due' | 'trialing';
type PaymentStatus = 'pending' | 'succeeded' | 'failed' | 'refunded';
type PaymentMethod = 'card' | 'bank_transfer';
type PaymentProvider = 'toss';
```

### 데이터 모델
```typescript
interface Subscription {
    id: string;
    userId: string;
    plan: SubscriptionPlan;
    status: SubscriptionStatus;
    currentPeriodStart: string | null;
    currentPeriodEnd: string | null;
    cancelAtPeriodEnd: boolean;
    paymentProvider: PaymentProvider | null;
    paymentCustomerId: string | null;
    paymentSubscriptionId: string | null;
    createdAt: string;
    updatedAt: string;
}

interface PaymentHistory {
    id: string;
    subscriptionId: string | null;
    userId: string;
    amount: number;
    currency: string;
    status: PaymentStatus;
    paymentMethod: PaymentMethod | null;
    paymentKey: string | null;
    orderId: string | null;
    receiptUrl: string | null;
    paidAt: string;
    createdAt: string;
}

interface PlanLimits {
    plan: SubscriptionPlan;
    maxGuidebooks: number;
    maxAiGenerationsPerMonth: number;
    watermarkRemoved: boolean;
    customDomain: boolean;
    prioritySupport: boolean;
    priceYearly: number;
    createdAt: string;
}
```

### UI 모델
```typescript
interface PricingCard {
    plan: SubscriptionPlan;
    name: string;
    description: string;
    price: number;
    monthlyPrice: number;
    features: string[];
    limits: PlanLimits;
    cta: string;
    isPopular?: boolean;
}

const PRICING_CARDS: PricingCard[] = [
    { plan: 'free', ... },    // Free 플랜
    { plan: 'pro', isPopular: true, ... },  // Pro 플랜 (인기)
    { plan: 'business', ... }  // Business 플랜
];
```

---

## 데이터 흐름

### 결제 플로우

```
사용자 플랜 선택
    ↓
POST /api/payments/request
├─ order_id 생성
├─ create_payment_record() 호출 (상태: pending)
└─ Toss 결제 페이지로 리다이렉트
    ↓
사용자가 Toss에서 결제
    ↓
Toss 콜백
POST /api/payments/confirm
├─ update_payment_status() (상태: pending → succeeded)
└─ update_subscription_from_payment() (구독 정보 업데이트)
    ↓
성공 응답 및 사용자 대시보드 갱신
```

### 구독 상태 확인 플로우

```
컴포넌트 마운트
    ↓
useSubscription() hook
    ↓
GET /api/subscriptions
├─ get_user_plan() → 현재 플랜
├─ get_plan_limits() → 제한 사항
└─ is_subscription_active() → 활성 여부
    ↓
UI에 구독 정보 표시
```

---

## 설치 방법 (3가지)

### 1. Supabase Dashboard (권장)
1. Dashboard SQL Editor 접속
2. `supabase/migrations/018_create_subscription_tables.sql` 복사
3. SQL Editor에 붙여넣고 실행

### 2. Supabase CLI
```bash
supabase db push
```

### 3. PostgreSQL CLI
```bash
psql -h [SUPABASE_HOST] -U postgres -d postgres \
     -f supabase/migrations/018_create_subscription_tables.sql
```

---

## 검증 항목

✅ **완료됨**

- [x] 마이그레이션 파일 작성 (340줄)
- [x] 3개 테이블 생성 (subscriptions, payment_history, plan_limits)
- [x] 7개 인덱스 생성 (성능 최적화)
- [x] 1개 트리거 생성 (updated_at 자동 관리)
- [x] 7개 RLS 정책 설정 (보안)
- [x] 7개 Helper 함수 구현 (비즈니스 로직)
- [x] TypeScript 타입 정의 (15개)
- [x] 초기 데이터 삽입 (plan_limits 3행)
- [x] 마이그레이션 요약 문서 작성
- [x] 완료 보고서 작성
- [x] 검증 및 설치 가이드 작성

---

## 주요 특징

### 1. 정규화된 스키마
- 각 테이블이 단일 책임 원칙 준수
- 불필요한 데이터 중복 없음
- 확장성 높음

### 2. 강력한 보안
- RLS 정책으로 행 수준 접근 제어
- Service Role 함수로 권한 분리
- SQL Injection 방지 (매개변수화된 쿼리)

### 3. 높은 성능
- 7개 인덱스로 빠른 조회
- 덮는 인덱스(Covering Index) 활용
- 자주 필터링되는 컬럼 인덱싱

### 4. 타입 안정성
- TypeScript 인터페이스로 런타임 오류 방지
- camelCase 변환으로 일관성 유지
- Union 타입으로 명확한 상태 관리

### 5. 가독성 및 유지보수성
- 코드에 TAG (@TASK, @SPEC) 추가
- 각 함수에 COMMENT 추가
- 문서 3개로 상세 설명

---

## 다음 단계

### P6-T6.2: 결제 API Route 구현
```
app/api/payments/
├── request/route.ts      (POST: 결제 요청)
├── confirm/route.ts      (POST: Toss 콜백)
└── status/route.ts       (GET: 결제 상태)

app/api/subscriptions/route.ts (GET: 구독 조회)
```

### P6-T6.3: 구독 UI 컴포넌트
```
components/subscription/
├── PricingSection.tsx       (가격 카드)
├── SubscriptionForm.tsx     (업그레이드 폼)
├── PaymentConfirm.tsx       (결제 확인)
└── SubscriptionStatus.tsx   (구독 상태)
```

### P6-T6.4: 구독 기능 통합
- 대시보드에 구독 정보 표시
- 플랜별 기능 제한 적용
- 플랜 업그레이드 플로우 구현

---

## 파일 위치

| 파일 | 경로 | 크기 |
|------|------|------|
| 마이그레이션 | `supabase/migrations/018_create_subscription_tables.sql` | 11KB |
| 타입 정의 | `src/types/subscription.ts` | 7.3KB |
| 마이그레이션 요약 | `supabase/migrations/018_MIGRATION_SUMMARY.md` | - |
| 완료 보고서 | `P6-T6.1-COMPLETION-REPORT.md` | 14KB |
| 검증 가이드 | `P6-T6.1-VERIFICATION.md` | - |

---

## 문제 해결

### Q: 마이그레이션 적용 오류
A: Supabase Dashboard에서 DROP 후 재실행:
```sql
DROP TABLE IF EXISTS payment_history CASCADE;
DROP TABLE IF EXISTS subscriptions CASCADE;
DROP TABLE IF EXISTS plan_limits CASCADE;
```

### Q: RLS 정책 작동 확인
A: Supabase Dashboard > Authentication > Policies에서 확인

### Q: 함수 호출 권한 오류
A: Service Role 함수는 API Route에서 `createAdminClient()` 사용

---

**작업 완료**: 2024-01-28
**상태**: ✅ PASS (모든 항목 완료)
**다음 태스크**: P6-T6.2 (결제 API Route 구현)
