# P6-T6.1 구독 DB 스키마 설계 및 마이그레이션 완료 보고서

## 작업 요약

구독 및 결제 기능을 위한 PostgreSQL 스키마를 설계하고 마이그레이션 스크립트를 작성했습니다.

## 완료 항목

### 1. 마이그레이션 파일
**파일**: `supabase/migrations/018_create_subscription_tables.sql`

#### 생성된 테이블 (3개)

| 테이블 | 목적 | 특징 |
|-------|------|------|
| **subscriptions** | 구독 정보 | user_id 1:1, 플랜/상태 관리, Toss 고객ID 저장 |
| **payment_history** | 결제 이력 | 결제 상태 추적, Toss 결제키, 영수증 URL |
| **plan_limits** | 플랜 제한 | 정적 데이터, free/pro/business 3가지 |

#### 생성된 인덱스 (7개)

```sql
-- subscriptions
idx_subscriptions_user_id
idx_subscriptions_payment_customer_id

-- payment_history
idx_payment_history_user_id
idx_payment_history_subscription_id
idx_payment_history_order_id
idx_payment_history_status
idx_payment_history_created_at
```

#### RLS 정책 (7개)

| 테이블 | 정책 | 규칙 |
|-------|------|------|
| subscriptions | SELECT | user_id = auth.uid() |
| subscriptions | INSERT | user_id = auth.uid() |
| subscriptions | UPDATE | user_id = auth.uid() |
| subscriptions | DELETE | user_id = auth.uid() |
| payment_history | SELECT | user_id = auth.uid() |
| payment_history | INSERT | user_id = auth.uid() |
| plan_limits | SELECT | true (공개) |

#### Helper 함수 (7개)

```sql
-- 조회 함수
get_user_plan(user_id) → TEXT
get_plan_limits(plan) → plan_limits
get_user_plan_limits(user_id) → plan_limits
is_subscription_active(user_id) → BOOLEAN

-- 결제 처리 함수 (Service Role 필요)
create_payment_record(...) → (id, created_at)
update_payment_status(...) → BOOLEAN
update_subscription_from_payment(...) → (id, user_id, plan, status)
```

---

### 2. TypeScript 타입 정의
**파일**: `src/types/subscription.ts`

#### 정의된 타입 (15개)

```typescript
// 열거형 타입
SubscriptionPlan = 'free' | 'pro' | 'business'
SubscriptionStatus = 'active' | 'canceled' | 'past_due' | 'trialing'
PaymentStatus = 'pending' | 'succeeded' | 'failed' | 'refunded'
PaymentMethod = 'card' | 'bank_transfer'
PaymentProvider = 'toss'

// 인터페이스
Subscription
PaymentHistory
PlanLimits
PaymentRequest
PaymentConfirmRequest
PaymentResponse
UpgradeSubscriptionRequest
CancelSubscriptionRequest
SubscriptionInfo
SubscriptionStatus (interface)
PricingCard

// 상수
PLAN_LIMITS_DEFAULTS: Record<SubscriptionPlan, PlanLimits>
PRICING_CARDS: PricingCard[]
```

---

### 3. 문서

#### 마이그레이션 요약
**파일**: `supabase/migrations/018_MIGRATION_SUMMARY.md`

- 전체 스키마 설명
- 각 테이블/함수별 상세 명세
- 데이터 흐름 (결제 플로우, 구독 상태 확인)
- 마이그레이션 검증 체크리스트

#### 검증 스크립트
**파일**: `scripts/verify-migration-018.sh`

- 테이블 존재 여부 확인
- RLS 정책 확인
- 초기 데이터 검증
- plan_limits 데이터 조회

---

## 스키마 설계 상세

### subscriptions 테이블 구조

```sql
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL UNIQUE REFERENCES auth.users(id),

    -- 플랜 정보
    plan TEXT DEFAULT 'free' -- CHECK: free|pro|business
    status TEXT DEFAULT 'active' -- CHECK: active|canceled|past_due|trialing

    -- 구독 기간
    current_period_start TIMESTAMPTZ
    current_period_end TIMESTAMPTZ
    cancel_at_period_end BOOLEAN DEFAULT FALSE

    -- Toss 결제 정보
    payment_provider TEXT -- 'toss'
    payment_customer_id TEXT UNIQUE
    payment_subscription_id TEXT

    -- 타임스탬프
    created_at TIMESTAMPTZ DEFAULT NOW()
    updated_at TIMESTAMPTZ DEFAULT NOW() -- trigger로 자동 업데이트
)
```

**설계 의사결정**:
- user_id는 UNIQUE로 1:1 관계 보장
- status를 분리하여 canceled, past_due 상태 추적 가능
- payment_customer_id로 Toss 고객 조회 최적화
- updated_at 트리거로 수정 시간 자동 관리

---

### payment_history 테이블 구조

```sql
CREATE TABLE payment_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    subscription_id UUID REFERENCES subscriptions(id) ON DELETE SET NULL,
    user_id UUID NOT NULL REFERENCES auth.users(id),

    -- 결제 정보
    amount INTEGER NOT NULL -- 원 단위
    currency TEXT DEFAULT 'KRW'
    status TEXT -- CHECK: pending|succeeded|failed|refunded
    payment_method TEXT -- 'card', 'bank_transfer'

    -- Toss 정보
    payment_key TEXT UNIQUE
    order_id TEXT UNIQUE
    receipt_url TEXT
    paid_at TIMESTAMPTZ

    created_at TIMESTAMPTZ DEFAULT NOW()
)
```

**설계 의사결정**:
- subscription_id를 FK로 하되 ON DELETE SET NULL (결제 기록 보존)
- order_id를 UNIQUE로 중복 결제 방지
- status를 통해 결제 상태 추적 (pending → succeeded)
- paid_at로 결제 완료 시간 기록

---

### plan_limits 테이블 구조

```sql
CREATE TABLE plan_limits (
    plan TEXT PRIMARY KEY, -- 'free', 'pro', 'business'

    -- 기능 제한
    max_guidebooks INTEGER -- -1: 무제한
    max_ai_generations_per_month INTEGER -- -1: 무제한

    -- 기능 활성화
    watermark_removed BOOLEAN
    custom_domain BOOLEAN
    priority_support BOOLEAN

    -- 가격
    price_yearly INTEGER -- 원, 연간 가격

    created_at TIMESTAMPTZ DEFAULT NOW()
)

-- 초기 데이터
INSERT INTO plan_limits VALUES
  ('free', 1, 3, FALSE, FALSE, FALSE, 0),
  ('pro', 5, 30, TRUE, FALSE, FALSE, 49000),
  ('business', -1, -1, TRUE, TRUE, TRUE, 99000);
```

**설계 의사결정**:
- 정적 데이터로 관리하여 데이터 일관성 보장
- -1을 무제한으로 사용 (명확한 의미)
- 연간 가격을 저장하여 월간/년간 계산 가능
- 기능별 불린으로 명확한 접근 제어

---

## 데이터 흐름

### 1. 구독 결제 플로우

```
┌─────────────┐
│  사용자가   │
│ Pro 플랜    │
│  선택      │
└──────┬──────┘
       │
       v
┌──────────────────────┐
│ POST /api/payments   │
│ /request             │
│ - plan: 'pro'        │
└──────┬───────────────┘
       │
       v
┌────────────────────────────────┐
│ 1. order_id 생성              │
│ 2. create_payment_record()      │
│    status='pending' 저장       │
│ 3. Toss 결제 페이지 리다이렉트 │
└──────┬─────────────────────────┘
       │
       v [사용자가 Toss에서 결제]
       │
┌──────────────────────┐
│ Toss 콜백           │
│ paymentKey 반환     │
└──────┬───────────────┘
       │
       v
┌─────────────────────────────────┐
│ POST /api/payments/confirm      │
│ - paymentKey, orderId, amount   │
└──────┬────────────────────────────┘
       │
       v
┌──────────────────────────────────────┐
│ 1. update_payment_status()           │
│    payment_history.status='succeeded'│
│ 2. update_subscription_from_payment()│
│    subscriptions 테이블 업데이트    │
│    - plan='pro', status='active'    │
│    - current_period_end=1년 후      │
└──────┬───────────────────────────────┘
       │
       v
┌──────────────────────┐
│ 성공 응답 반환      │
│ 사용자 대시보드 갱신 │
└──────────────────────┘
```

### 2. 구독 상태 조회 플로우

```
┌──────────────────────┐
│ useSubscription()    │
│ hook 실행            │
└──────┬───────────────┘
       │
       v
┌──────────────────────────────────┐
│ GET /api/subscriptions           │
│ - 현재 사용자의 구독 조회        │
└──────┬───────────────────────────┘
       │
       v
┌──────────────────────────────────┐
│ 1. get_user_plan(user_id)        │
│    → plan='pro' (or 'free')      │
│ 2. get_plan_limits('pro')        │
│    → maxGuidebooks=5, ...        │
│ 3. is_subscription_active()      │
│    → true/false                  │
└──────┬───────────────────────────┘
       │
       v
┌──────────────────────┐
│ SubscriptionInfo     │
│ - currentPlan        │
│ - limits             │
│ - isActive           │
│ - daysUntilExpiry    │
└──────────────────────┘
```

---

## 마이그레이션 적용 방법

### 방법 1: Supabase Dashboard
1. Supabase Dashboard > SQL Editor 접속
2. `supabase/migrations/018_create_subscription_tables.sql` 전체 복사
3. SQL Editor에 붙여넣고 실행

### 방법 2: Supabase CLI
```bash
# 마이그레이션 파일 확인
supabase migration list

# 마이그레이션 적용
supabase migration up

# 로컬 개발 환경에서만
supabase db reset
```

### 방법 3: PostgreSQL psql
```bash
# Supabase 접속 정보 설정
psql -h bzzdaptscqkshwqehpmc.supabase.co \
     -U postgres \
     -d postgres \
     -f supabase/migrations/018_create_subscription_tables.sql
```

---

## 검증 방법

### 1. 테이블 생성 확인
```sql
SELECT tablename FROM pg_tables
WHERE schemaname = 'public'
AND tablename IN ('subscriptions', 'payment_history', 'plan_limits');
```

### 2. 인덱스 확인
```sql
SELECT indexname FROM pg_indexes
WHERE tablename IN ('subscriptions', 'payment_history')
ORDER BY indexname;
```

### 3. RLS 정책 확인
```sql
SELECT schemaname, tablename, policyname, permissive, roles, qual
FROM pg_policies
WHERE tablename IN ('subscriptions', 'payment_history', 'plan_limits');
```

### 4. 함수 확인
```sql
SELECT routinename FROM information_schema.routines
WHERE routine_schema = 'public'
AND routinename LIKE '%subscription%' OR routinename LIKE '%payment%';
```

### 5. 초기 데이터 확인
```sql
SELECT * FROM plan_limits ORDER BY plan;
```

---

## TypeScript 타입 사용 예시

### API Route에서
```typescript
// app/api/subscriptions/route.ts
import { Subscription, PaymentHistory, PlanLimits } from '@/types/subscription';

export async function GET(req: Request) {
    const user = await getUser();

    // Supabase에서 조회
    const { data: subscription } = await supabase
        .from('subscriptions')
        .select('*')
        .eq('user_id', user.id)
        .single();

    const subscription: Subscription = {
        ...subscription,
        userId: subscription.user_id,
        plan: subscription.plan as SubscriptionPlan,
        // ...
    };

    return Response.json(subscription);
}
```

### 컴포넌트에서
```typescript
// components/subscription/SubscriptionCard.tsx
import { PRICING_CARDS, PricingCard } from '@/types/subscription';

export function PricingSection() {
    return (
        <div className="grid grid-cols-3 gap-4">
            {PRICING_CARDS.map((card: PricingCard) => (
                <div key={card.plan}>
                    <h2>{card.name}</h2>
                    <p className="text-2xl">
                        {card.monthlyPrice.toLocaleString('ko-KR')}원/월
                    </p>
                </div>
            ))}
        </div>
    );
}
```

---

## 다음 단계

### P6-T6.2: 결제 API Route 구현
- `app/api/payments/request` - 결제 요청
- `app/api/payments/confirm` - 결제 확인 (Toss 콜백)
- `app/api/subscriptions` - 구독 조회
- Toss Payments API 연동

### P6-T6.3: 구독 UI 컴포넌트
- `PricingSection` - 가격 카드 표시
- `SubscriptionForm` - 업그레이드 폼
- `PaymentConfirm` - 결제 확인 모달
- 플랜별 기능 잠금 UI

---

## 완료 기준 확인

- [x] `subscriptions` 테이블 생성
- [x] `payment_history` 테이블 생성
- [x] `plan_limits` 테이블 생성 (초기 데이터)
- [x] RLS 정책 설정 (7개)
- [x] Helper 함수 구현 (7개)
- [x] TypeScript 타입 정의 (15개)
- [x] 마이그레이션 요약 문서
- [x] 검증 스크립트

---

## 파일 목록

| 파일 | 설명 |
|------|------|
| `supabase/migrations/018_create_subscription_tables.sql` | 마이그레이션 스크립트 |
| `supabase/migrations/018_MIGRATION_SUMMARY.md` | 마이그레이션 상세 문서 |
| `src/types/subscription.ts` | TypeScript 타입 정의 |
| `scripts/verify-migration-018.sh` | 검증 스크립트 |
| `P6-T6.1-COMPLETION-REPORT.md` | 본 문서 |

---

## 문제 해결

### Q: 마이그레이션 적용 후 오류가 발생했을 때
A: Supabase Dashboard > SQL Editor에서 다음을 실행:
```sql
-- 테이블 삭제 (주의: 데이터 손실)
DROP TABLE IF EXISTS payment_history CASCADE;
DROP TABLE IF EXISTS subscriptions CASCADE;
DROP TABLE IF EXISTS plan_limits CASCADE;

-- 마이그레이션 다시 실행
```

### Q: RLS 정책이 작동하지 않을 때
A: RLS 정책이 활성화되었는지 확인:
```sql
SELECT schemaname, tablename, rowsecurity
FROM pg_tables
WHERE tablename IN ('subscriptions', 'payment_history', 'plan_limits');
-- rowsecurity = true 확인
```

### Q: 타입 에러가 발생했을 때
A: snake_case → camelCase 변환 확인:
```typescript
// DB: user_id → TS: userId
// DB: current_period_start → TS: currentPeriodStart
```

---

**작성일**: 2024-01-28
**태스크**: P6-T6.1
**상태**: 완료 ✅
