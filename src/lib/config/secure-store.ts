/**
 * Secure Configuration Store
 *
 * Manages environment variables and configuration validation for the setup process.
 * Supports two storage modes:
 * 1. .env.local (default, simple)
 * 2. Encrypted config file (advanced, optional)
 */

import { z } from 'zod';
import { createClient } from '@supabase/supabase-js';

// Configuration schema with validation
export const SupabaseConfigSchema = z.object({
  url: z.string().url('Invalid Supabase URL format'),
  anonKey: z.string().min(1, 'Anon key is required'),
  serviceRoleKey: z.string().min(1, 'Service role key is required').optional(),
});

export const TossConfigSchema = z.object({
  clientKey: z.string().min(1, 'Toss client key is required').optional(),
  secretKey: z.string().min(1, 'Toss secret key is required').optional(),
});

export const SiteConfigSchema = z.object({
  name: z.string().min(1, 'Site name is required'),
  url: z.string().url('Invalid site URL format'),
  adminEmail: z.string().email('Invalid email format'),
  logoUrl: z.string().url('Invalid logo URL format').optional(),
});

export const SetupConfigSchema = z.object({
  supabase: SupabaseConfigSchema,
  toss: TossConfigSchema.optional(),
  site: SiteConfigSchema,
});

export type SupabaseConfig = z.infer<typeof SupabaseConfigSchema>;
export type TossConfig = z.infer<typeof TossConfigSchema>;
export type SiteConfig = z.infer<typeof SiteConfigSchema>;
export type SetupConfig = z.infer<typeof SetupConfigSchema>;

/**
 * Test Supabase connection
 */
export async function testSupabaseConnection(config: SupabaseConfig): Promise<{
  success: boolean;
  error?: string;
}> {
  try {
    const supabase = createClient(config.url, config.anonKey);

    // Try to query profiles table (should exist after migrations)
    const { error } = await supabase.from('profiles').select('id').limit(1);

    if (error) {
      // Check if it's an auth error (no RLS) or table doesn't exist
      if (error.message.includes('relation') && error.message.includes('does not exist')) {
        return {
          success: false,
          error: 'Database tables not found. Please run migrations first.',
        };
      }

      // RLS policy might block access, but connection is OK
      if (error.message.includes('policy')) {
        return { success: true };
      }

      return {
        success: false,
        error: `Connection failed: ${error.message}`,
      };
    }

    return { success: true };
  } catch (err) {
    return {
      success: false,
      error: err instanceof Error ? err.message : 'Unknown error occurred',
    };
  }
}

/**
 * Validate Supabase keys format
 */
export function validateSupabaseKeys(config: SupabaseConfig): {
  valid: boolean;
  errors: string[];
} {
  const errors: string[] = [];

  // URL validation
  if (!config.url.includes('supabase.co') && !config.url.includes('localhost')) {
    errors.push('URL should be a valid Supabase URL (*.supabase.co)');
  }

  // Anon key validation (JWT format check)
  if (!config.anonKey.startsWith('eyJ')) {
    errors.push('Anon key should be a valid JWT token (starts with eyJ)');
  }

  // Service role key validation
  if (config.serviceRoleKey && !config.serviceRoleKey.startsWith('eyJ')) {
    errors.push('Service role key should be a valid JWT token (starts with eyJ)');
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Get current configuration status
 */
export function getConfigurationStatus(): {
  configured: boolean;
  hasSupabase: boolean;
  hasToss: boolean;
  hasSite: boolean;
} {
  const hasSupabase = !!(
    process.env.NEXT_PUBLIC_SUPABASE_URL &&
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
  );

  const hasToss = !!(
    process.env.TOSS_CLIENT_KEY &&
    process.env.TOSS_SECRET_KEY
  );

  const hasSite = !!(
    process.env.NEXT_PUBLIC_SITE_NAME &&
    process.env.NEXT_PUBLIC_APP_URL
  );

  return {
    configured: hasSupabase && hasSite,
    hasSupabase,
    hasToss,
    hasSite,
  };
}

/**
 * Format configuration for .env.local file
 */
export function formatEnvFile(config: SetupConfig): string {
  const lines: string[] = [
    '# Auto-generated by Setup Wizard',
    '# Do not commit this file to version control',
    '',
    '# Supabase Configuration',
    `NEXT_PUBLIC_SUPABASE_URL=${config.supabase.url}`,
    `NEXT_PUBLIC_SUPABASE_ANON_KEY=${config.supabase.anonKey}`,
  ];

  if (config.supabase.serviceRoleKey) {
    lines.push(`SUPABASE_SERVICE_ROLE_KEY=${config.supabase.serviceRoleKey}`);
  }

  if (config.toss?.clientKey && config.toss?.secretKey) {
    lines.push(
      '',
      '# Toss Payments Configuration',
      `TOSS_CLIENT_KEY=${config.toss.clientKey}`,
      `TOSS_SECRET_KEY=${config.toss.secretKey}`
    );
  }

  lines.push(
    '',
    '# Site Configuration',
    `NEXT_PUBLIC_SITE_NAME=${config.site.name}`,
    `NEXT_PUBLIC_APP_URL=${config.site.url}`,
    `ADMIN_EMAIL=${config.site.adminEmail}`
  );

  if (config.site.logoUrl) {
    lines.push(`NEXT_PUBLIC_LOGO_URL=${config.site.logoUrl}`);
  }

  lines.push('');

  return lines.join('\n');
}

/**
 * Error messages for common setup issues
 */
export const SETUP_ERROR_MESSAGES = {
  INVALID_URL: 'Please enter a valid Supabase project URL (format: https://xxx.supabase.co)',
  INVALID_ANON_KEY: 'Anon key should be a JWT token starting with "eyJ"',
  INVALID_SERVICE_KEY: 'Service role key should be a JWT token starting with "eyJ"',
  CONNECTION_FAILED: 'Failed to connect to Supabase. Please check your credentials.',
  TABLES_NOT_FOUND: 'Database tables not found. Please run migrations first (npm run db:migrate)',
  ALREADY_CONFIGURED: 'Setup already completed. Delete .env.local to reconfigure.',
  INVALID_EMAIL: 'Please enter a valid email address',
  INVALID_SITE_URL: 'Please enter a valid site URL (format: https://example.com)',
} as const;
